------------
libcomm14cux
http://code.google.com/p/libcomm14cux
------------
libcomm14cux is a cross-platform library that is capable of communicating with
the Lucas 14CUX ECU via its diagnostic serial port. Special hardware is required
to match the ECU's signaling scheme; the hardware is beyond the scope of this
document and detailed on the following web site:

http://alum.wpi.edu/~colinb/14cux_interface.html
Mirror: http://code.google.com/p/libcomm14cux/wiki/HardwareInterface

The library itself has no user-interface and requires a front-end application
to display data. Included in this archive is a simple command-line utility
(named "read14cux") which uses the library to read and display bytes from the
14CUX's memory. The RoverGauge project provides a graphical front-end to this
library:

http://code.google.com/p/rovergauge

To assist in the development of other front-ends, the source archive can be
used to generate HTML documentation of the API. This is done by running Doxygen
on the provided doxygen.conf file (in the src/ directory.)

Comments, questions, bug reports, and bugfixes should be directed to
colin.bourassa@gmail.com. Please include the version number of the library in
any correspondence.

-------
License
-------
libcomm14cux is licensed under the GPL v3. See the file "LICENSE" for details.

----------
Disclaimer
----------
While this software has been shown to be reliable and is provided in good
faith, it is provided with ABSOLUTELY NO WARRANTY.

---------
Changelog
---------
1.2.0: Added function to retrieve final fueling value
       Added sanity checking for several readings
       Changed function signature for getRoadSpeed to use a smaller type
1.1.0: Fixed bug with left/right bank confusion
       Modified getTuneRevision() to also return Ident byte and checksum fixer
       Added function to retrieve MAF CO trim voltage
1.0.0: Converted the interface from C++ to pure C
0.5.5: Updated serial port setup for better cross-platform compatibility
       Added code for compatibility with Mac OS X >= 10.6
0.5.4: Added functions to retrieve the idle-mode status and MIL status;
       also miscellaneous cleanup
0.5.3: Fixed polarity of short-term lambda trim; it was previously reversed
0.5.2: Added switchable absolute/corrected throttle position readings
0.5.1: Support for old revision of ECU (fixing main voltage calculation)
0.5.0: Added more fault codes, as well as fault code numbers
       Added switchable short/long term lambda fuel trim
       Added switchable linearized/direct MAF readings
0.4.4: Improved main voltage reading accuracy further
       Improved throttle pot position accuracy
0.4.2: Added function to retrieve lambda fuel trim
       Improved main voltage reading accuracy
0.4.1: Added functions to control the fuel pump and the idle air control valve
       Added function to get target idle speed
0.3.2: Added function to get fuel pump relay state and function to clear
       fault codes
0.3.1: Cleanup of Doxygen comments
0.3.0: Changed MAF reading call to return a percentage rather than raw value
       Added support for fuel map 0
       Improved efficiency of consecutive read commands to nearby addresses
       Added support for cancelling long read operations
0.2.0: Added routines for retrieving a number of specific values, such as
        engine RPM, coolant and fuel temperatures, and road speed.
0.1.1: Cleanup of Doxygen comments
0.1.0: Initial version

-------------
Compatibility
-------------
libcomm14cux has been tested with the following operating systems:

* Linux (Ubuntu 13.10, i386 / AMD64)
* OpenBSD 5.2 (AMD64)
* FreeBSD 9.0 (AMD64)
* Windows XP
* Windows 7
* Macintosh OS X 10.6

Note that installation packages are not available for some of the OSs listed
above, but it is possible to build from source for those platforms (see
"Building the library from source", below.)

---------------
Using read14cux
---------------
The libcomm14cux library must be visible to the read14cux executable for it to
run. (In Windows, the most straightforward way to do this is to ensure that the
DLL and read14cux.exe are in the same directory.)

The read14cux utility reads a specified number of bytes from a specified memory
location in the ECU, and will either display those bytes at the console (16
bytes per line), or, if an output filename is given, write the bytes to a file.

The read14cux command line parameters are as follows:

  read14cux <serial-device> <address> <length> [output-file]

  serial-device:
    The name of the serial port device, which is probably an FTDI USB converter.
    In recent Linux distributions, it's probably "/dev/ttyUSB0". In Windows,
    it's a COM port (such as "COM2") -- the specific COM port can be found by
    locating the serial device in the Windows Device Manager.

  address:
    Memory address at which to start reading data. This should be specified in
    hex (using the "0x" prefix, as in "0xC000".)

  length:
    Number of bytes to read.

  output-file:
    Optional. If given, the file to which the bytes will be written (rather than
    to the console.)

------------------------------------------
Issues with writing to memory in the 14CUX
------------------------------------------
Write operations are of limited usefulness; fuel maps cannot be changed in this
way because they are read from the ROM, and sensor readings are continually
updated by the ECU (meaning that any change to the memory location of a sensor
value would almost immediately be overwritten.)

Care should be taken when writing memory while the engine is running; it's
possible to affect the operation of the fuel pump or idle-control stepper motor
in this way.

--------------------------------
Building the library from source
--------------------------------
The libcomm14cux library can be built using Linux, BSD, OS X, or Windows.

Note that the makefile generated by CMake will produce output appropriate for
the operating system. In Linux, the output is a dynamic shared object (DSO)
file, named something like "libcomm14cux.so.1.0.0". In Windows, the output is a
DLL, named something like "libcomm14cux.dll".

CMake can be obtained from www.cmake.org, and MinGW from www.mingw.org.


== Building for Linux / BSD / OS X ==

The following software is required:

* CMake (>= 2.8)
* gcc (or equivalent)
* make

From the directory containing the libcomm14cux source code, execute the
following:

$ cmake .
$ make
$ sudo make install

Running the 'make install' directive will copy the header files to /usr/include
and the shared library to /usr/lib. These directories can be changed by editing
CMakeLists.txt and re-running "cmake ." and "make install". You may want to do
this if you do not have superuser/administrator privileges on the machine.


== Building for Windows ==

A Windows build requires the following software:

* CMake (>= 2.8)
* MinGW

Note that the MinGW Project also provides "MSYS", which is a more complete GNU
environment; installation of MSYS is _not_ necessary to build libcomm14cux.

After CMake and MinGW are installed, run the following commands from a command
prompt in the directory containing the libcomm14cux source:

 cmake . -G "MinGW Makefiles"
 make
 make install

Note: the 'install' directive under Windows will copy the output DLL, read14cux
executable, and header files to C:\comm14cux by default. If the user running
the 'make install' step does not have write permissions at C:\, this step may
fail.

----------------------------------------------------
Notes for those developing frontends to libcomm14cux
----------------------------------------------------
Because Windows still uses legacy DOS names for certain devices (such as COM
ports), there are restrictions on how such devices may be manipulated by code.
In order to open COM ports beyond COM9, Windows I/O calls (such as CreateFile())
require use of the prefix "\\.\" on the device name, as in "\\.\COM10". (Also
note that the backslashes must be properly escaped where appropriate.)

(EOF)
